import "../../paths-CyR9Pa1R.js";
import { dt as isGatewayStartupEvent, r as defaultRuntime, t as createSubsystemLogger } from "../../subsystem-NZzGD1xL.js";
import { l as resolveAgentIdFromSessionKey } from "../../session-key-CsUx6Yfs.js";
import { s as resolveAgentWorkspaceDir, t as listAgentIds } from "../../agent-scope-DGv_lb5V.js";
import "../../workspace-DSaPuILJ.js";
import { n as SILENT_REPLY_TOKEN } from "../../tokens-D_6bHP0d.js";
import { a as createDefaultDeps, i as agentCommand } from "../../pi-embedded-b5EhLFgE.js";
import "../../plugins-DRxcIsdW.js";
import "../../accounts-BdsaOk1K.js";
import "../../boolean-mcn6kL0s.js";
import "../../command-format-DkQnibeb.js";
import "../../bindings-BAjLQTjN.js";
import "../../send-Ds-2XF5y.js";
import "../../send-B5wXuvAU.js";
import "../../deliver-CH3Y5bRD.js";
import "../../diagnostic-KeVQjolu.js";
import "../../diagnostic-session-state-Bxo4UHOL.js";
import "../../accounts-Bnm1qsMy.js";
import "../../send-DJHamGpM.js";
import "../../image-ops-D_0HqKCn.js";
import "../../model-auth-D7yExN0T.js";
import "../../github-copilot-token-Dgb9dAHW.js";
import "../../pi-model-discovery-DaNAekda.js";
import "../../message-channel-CGfDQO-K.js";
import "../../pi-embedded-helpers-DxTyisc4.js";
import "../../config-Co-5D6Gn.js";
import "../../manifest-registry-CBHbnE_M.js";
import "../../dock-EZ2jebb_.js";
import "../../chrome-B1nMBMAN.js";
import "../../ssrf-DoQDLHSj.js";
import "../../frontmatter-CGOZnTsi.js";
import "../../skills-CfaId93d.js";
import "../../redact-CpDh05JC.js";
import "../../errors-xxnHvoWf.js";
import "../../store-LAmaIatB.js";
import { V as resolveMainSessionKey, d as updateSessionStore, s as loadSessionStore, z as resolveAgentMainSessionKey } from "../../sessions-The2KDBw.js";
import "../../accounts-CU1yRDCa.js";
import { l as resolveStorePath } from "../../paths-DZd1zVsd.js";
import "../../tool-images-Dq_CJUOG.js";
import "../../thinking-Ds6fxj9u.js";
import "../../image-Cl4RgYGS.js";
import "../../reply-prefix-CcHHKxqr.js";
import "../../manager-CzYqmNNc.js";
import "../../gemini-auth-BkfXMw6M.js";
import "../../fetch-guard-BlZG4Lmu.js";
import "../../query-expansion-CEv78HTf.js";
import "../../retry-R2-ijxad.js";
import "../../target-errors-BCxkxt23.js";
import "../../chunk-BfP6KnSJ.js";
import "../../markdown-tables-D2nzL-yS.js";
import "../../local-roots-BpEzzsZA.js";
import "../../ir-CVhLchLc.js";
import "../../render-D7U4wOLO.js";
import "../../commands-registry-B_RJj3YI.js";
import "../../skill-commands-s4CyL99S.js";
import "../../runner-CjFAR0P3.js";
import "../../fetch-xJrgyxIC.js";
import "../../channel-activity-CeK8ljUk.js";
import "../../tables-EWdJXa91.js";
import "../../send-OrSUUlSK.js";
import "../../outbound-attachment-Cb2EusK2.js";
import "../../send-D9xANWuj.js";
import "../../resolve-route-C9fIfNqd.js";
import "../../proxy-DTBHP1Tj.js";
import "../../replies-DS7HJuGD.js";
import fs from "node:fs/promises";
import path from "node:path";
import crypto from "node:crypto";

//#region src/gateway/boot.ts
function generateBootSessionId() {
	return `boot-${(/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-").replace("T", "_").replace("Z", "")}-${crypto.randomUUID().slice(0, 8)}`;
}
const log$1 = createSubsystemLogger("gateway/boot");
const BOOT_FILENAME = "BOOT.md";
function buildBootPrompt(content) {
	return [
		"You are running a boot check. Follow BOOT.md instructions exactly.",
		"",
		"BOOT.md:",
		content,
		"",
		"If BOOT.md asks you to send a message, use the message tool (action=send with channel + target).",
		"Use the `target` field (not `to`) for message tool destinations.",
		`After sending with the message tool, reply with ONLY: ${SILENT_REPLY_TOKEN}.`,
		`If nothing needs attention, reply with ONLY: ${SILENT_REPLY_TOKEN}.`
	].join("\n");
}
async function loadBootFile(workspaceDir) {
	const bootPath = path.join(workspaceDir, BOOT_FILENAME);
	try {
		const trimmed = (await fs.readFile(bootPath, "utf-8")).trim();
		if (!trimmed) return { status: "empty" };
		return {
			status: "ok",
			content: trimmed
		};
	} catch (err) {
		if (err.code === "ENOENT") return { status: "missing" };
		throw err;
	}
}
function snapshotMainSessionMapping(params) {
	const agentId = resolveAgentIdFromSessionKey(params.sessionKey);
	const storePath = resolveStorePath(params.cfg.session?.store, { agentId });
	try {
		const entry = loadSessionStore(storePath, { skipCache: true })[params.sessionKey];
		if (!entry) return {
			storePath,
			sessionKey: params.sessionKey,
			canRestore: true,
			hadEntry: false
		};
		return {
			storePath,
			sessionKey: params.sessionKey,
			canRestore: true,
			hadEntry: true,
			entry: structuredClone(entry)
		};
	} catch (err) {
		log$1.debug("boot: could not snapshot main session mapping", {
			sessionKey: params.sessionKey,
			error: String(err)
		});
		return {
			storePath,
			sessionKey: params.sessionKey,
			canRestore: false,
			hadEntry: false
		};
	}
}
async function restoreMainSessionMapping(snapshot) {
	if (!snapshot.canRestore) return;
	try {
		await updateSessionStore(snapshot.storePath, (store) => {
			if (snapshot.hadEntry && snapshot.entry) {
				store[snapshot.sessionKey] = snapshot.entry;
				return;
			}
			delete store[snapshot.sessionKey];
		}, { activeSessionKey: snapshot.sessionKey });
		return;
	} catch (err) {
		return err instanceof Error ? err.message : String(err);
	}
}
async function runBootOnce(params) {
	const bootRuntime = {
		log: () => {},
		error: (message) => log$1.error(String(message)),
		exit: defaultRuntime.exit
	};
	let result;
	try {
		result = await loadBootFile(params.workspaceDir);
	} catch (err) {
		const message = err instanceof Error ? err.message : String(err);
		log$1.error(`boot: failed to read ${BOOT_FILENAME}: ${message}`);
		return {
			status: "failed",
			reason: message
		};
	}
	if (result.status === "missing" || result.status === "empty") return {
		status: "skipped",
		reason: result.status
	};
	const sessionKey = params.agentId ? resolveAgentMainSessionKey({
		cfg: params.cfg,
		agentId: params.agentId
	}) : resolveMainSessionKey(params.cfg);
	const message = buildBootPrompt(result.content ?? "");
	const sessionId = generateBootSessionId();
	const mappingSnapshot = snapshotMainSessionMapping({
		cfg: params.cfg,
		sessionKey
	});
	let agentFailure;
	try {
		await agentCommand({
			message,
			sessionKey,
			sessionId,
			deliver: false
		}, bootRuntime, params.deps);
	} catch (err) {
		agentFailure = err instanceof Error ? err.message : String(err);
		log$1.error(`boot: agent run failed: ${agentFailure}`);
	}
	const mappingRestoreFailure = await restoreMainSessionMapping(mappingSnapshot);
	if (mappingRestoreFailure) log$1.error(`boot: failed to restore main session mapping: ${mappingRestoreFailure}`);
	if (!agentFailure && !mappingRestoreFailure) return { status: "ran" };
	return {
		status: "failed",
		reason: [agentFailure ? `agent run failed: ${agentFailure}` : void 0, mappingRestoreFailure ? `mapping restore failed: ${mappingRestoreFailure}` : void 0].filter((part) => Boolean(part)).join("; ")
	};
}

//#endregion
//#region src/hooks/bundled/boot-md/handler.ts
const log = createSubsystemLogger("hooks/boot-md");
const runBootChecklist = async (event) => {
	if (!isGatewayStartupEvent(event)) return;
	if (!event.context.cfg) return;
	const cfg = event.context.cfg;
	const deps = event.context.deps ?? createDefaultDeps();
	const agentIds = listAgentIds(cfg);
	for (const agentId of agentIds) {
		const workspaceDir = resolveAgentWorkspaceDir(cfg, agentId);
		const result = await runBootOnce({
			cfg,
			deps,
			workspaceDir,
			agentId
		});
		if (result.status === "failed") {
			log.warn("boot-md failed for agent startup run", {
				agentId,
				workspaceDir,
				reason: result.reason
			});
			continue;
		}
		if (result.status === "skipped") log.debug("boot-md skipped for agent startup run", {
			agentId,
			workspaceDir,
			reason: result.reason
		});
	}
};

//#endregion
export { runBootChecklist as default };