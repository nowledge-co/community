import "./paths-B4BZAPZh.js";
import { B as theme, P as setVerbose, k as info, z as isRich } from "./utils-DCtXtPui.js";
import "./thinking-EAliFiVK.js";
import { E as resolveSessionModelRef, mr as lookupContextTokens, y as classifySessionKey } from "./reply-IQbtp7d2.js";
import { f as defaultRuntime } from "./subsystem-CYc2uK4P.js";
import { C as parseAgentSessionKey } from "./session-key-D7AdMgCp.js";
import "./exec-QOib7mc9.js";
import "./agent-scope-CJ4YDowp.js";
import { Jt as DEFAULT_PROVIDER, Kt as DEFAULT_CONTEXT_TOKENS, p as resolveConfiguredModelRef, qt as DEFAULT_MODEL } from "./model-selection-jLPRV2hp.js";
import "./github-copilot-token-nncItI8D.js";
import "./boolean-BgXe2hyu.js";
import "./env-Bi5nSj2_.js";
import "./host-env-security-ljCLeQmh.js";
import "./message-channel-CboOXQ5K.js";
import "./send-BY7zV9nk.js";
import { i as loadConfig } from "./config-D9td3nQ8.js";
import "./env-vars-CvvqezS9.js";
import "./manifest-registry-6Smo6hJJ.js";
import "./dock-CrncBkrf.js";
import "./runner-BUtmTMJt.js";
import "./image-CLf6LO9A.js";
import "./models-config-B2VsCrQB.js";
import "./pi-model-discovery-Bakt-Qrp.js";
import "./pi-embedded-helpers-husLPufc.js";
import "./sandbox-BfRAzU9M.js";
import "./chrome-DFWJJMOL.js";
import "./tailscale-BQzlD90q.js";
import "./ip-DdJWkGLX.js";
import "./tailnet-hl3MDqWZ.js";
import "./ws-CxontMkm.js";
import "./auth-lSe2vcAf.js";
import "./server-context-BLGh1cTt.js";
import "./frontmatter-CDXvVVtB.js";
import "./skills-DikywEzc.js";
import "./routes-CmNAokG-.js";
import "./redact-DUz7OAYQ.js";
import "./errors-botak1wn.js";
import "./fs-safe-g1vUuj4t.js";
import "./paths-Bt1FN5h-.js";
import "./ssrf-CTVJWS7u.js";
import "./image-ops-CBA3OF6h.js";
import "./store-DLffydGb.js";
import "./ports-Bnye_-N3.js";
import "./trash-DjbQC3BX.js";
import { V as resolveFreshSessionTotalTokens, s as loadSessionStore } from "./sessions-CX6bjL0O.js";
import "./plugins-D_vAsEMg.js";
import "./accounts-BIx69xGF.js";
import "./accounts-C-pe2tSL.js";
import "./accounts-ZHIyNWMM.js";
import "./bindings-BycbLu-x.js";
import "./logging-CeI8pPxx.js";
import "./send-CT9FYldt.js";
import { l as resolveStorePath } from "./paths-CIwUV7XC.js";
import "./chat-envelope-0XVRE01I.js";
import "./tool-images-DUVex7kP.js";
import "./tool-display-C35ig9vC.js";
import "./fetch-guard-BCyCEMa-.js";
import "./api-key-rotation-Ue869V2Q.js";
import "./local-roots-C5LXTTKp.js";
import "./query-expansion-BQGEYyfx.js";
import "./model-catalog-BE-IzAGl.js";
import "./tokens-DpHv7nsB.js";
import "./with-timeout-DQ_rUhjZ.js";
import "./deliver-GkW9X1sl.js";
import "./diagnostic-CQQqMOqv.js";
import "./diagnostic-session-state-Ch_54kt9.js";
import "./send-DwcpjBNb.js";
import "./model-D8oSNHP2.js";
import "./exec-approvals-allowlist-Pm7wXPE_.js";
import "./exec-safe-bin-runtime-policy-Bgl82M3E.js";
import "./reply-prefix-BHd-zlJx.js";
import "./memory-cli-DZS6VQFD.js";
import "./manager-BlOF08go.js";
import "./retry-DjEkIJ6_.js";
import "./target-errors-DGRZmMY-.js";
import "./chunk-RldsjIe1.js";
import "./markdown-tables-B18tIhkM.js";
import "./ir--ucfTyaW.js";
import "./render-Bdn0My43.js";
import "./commands-xtsUE-jY.js";
import "./commands-registry-BAhtj8hc.js";
import "./client-CfOpOyvw.js";
import "./call-BV1LTlF4.js";
import "./pairing-token-DNk38FMB.js";
import { n as formatTimeAgo } from "./format-relative-DU9tLpjp.js";
import "./channel-activity-DmI9-88U.js";
import "./fetch-CuzXpoec.js";
import "./tables-COrQ8TYe.js";
import "./send--cEk3CEv.js";
import "./pairing-store-UK0msBm-.js";
import "./proxy-DWpYcsvR.js";
import { t as formatDocsLink } from "./links-Xz2s6XZA.js";
import { n as runCommandWithRuntime } from "./cli-utils-tNdOjVQI.js";
import { t as formatHelpExamples } from "./help-format-D28_gnAS.js";
import "./progress-ebTx2ghO.js";
import "./resolve-route-V6LlA6UT.js";
import "./replies-ColktvbC.js";
import "./skill-commands-D90q9JIT.js";
import "./workspace-dirs-BZgSonti.js";
import "./channel-selection-B9R2emW6.js";
import "./outbound-attachment-B8vrFWwW.js";
import "./delivery-queue-C_yXc_uy.js";
import "./session-cost-usage-RWqVNJVh.js";
import "./send-ByYHS3ru.js";
import "./onboard-helpers-D_b_dmpO.js";
import "./prompt-style-BBhZVg0K.js";
import "./pairing-labels-Ds8hJeIa.js";
import "./exec-approvals-CeC-ynkl.js";
import "./nodes-screen-BPsdZvFO.js";
import "./control-service-DbPEGVYQ.js";
import "./stagger-CA349KVs.js";
import "./pi-tools.policy-DffWPFUp.js";
import "./runtime-guard-CdzxWI2g.js";
import { n as parsePositiveIntOrUndefined } from "./helpers-Doq6E0RM.js";
import "./skills-status-Bw0JsJlq.js";
import "./dangerous-tools-aukizCQY.js";
import "./skill-scanner-BHhUFXAR.js";
import "./channels-status-issues-B-PC8fwJ.js";
import "./systemd-vDnv5x1P.js";
import "./service-_YCp5cx5.js";
import "./diagnostics-CCGzI7oN.js";
import "./table-CZ7i53VY.js";
import "./audit-BgSoRTb-.js";
import { t as statusCommand } from "./status-bCOCejkZ.js";
import { r as healthCommand } from "./health-B2aDhUNe.js";
import "./channel-account-context-DspjZjv0.js";
import "./dm-policy-shared-C5IM7Ujy.js";
import "./node-service-DiOwWHRv.js";
import "./status.update-CSm__6WS.js";

//#region src/commands/sessions.ts
const KIND_PAD = 6;
const KEY_PAD = 26;
const AGE_PAD = 9;
const MODEL_PAD = 14;
const TOKENS_PAD = 20;
const formatKTokens = (value) => `${(value / 1e3).toFixed(value >= 1e4 ? 0 : 1)}k`;
const truncateKey = (key) => {
	if (key.length <= KEY_PAD) return key;
	const head = Math.max(4, KEY_PAD - 10);
	return `${key.slice(0, head)}...${key.slice(-6)}`;
};
const colorByPct = (label, pct, rich) => {
	if (!rich || pct === null) return label;
	if (pct >= 95) return theme.error(label);
	if (pct >= 80) return theme.warn(label);
	if (pct >= 60) return theme.success(label);
	return theme.muted(label);
};
const formatTokensCell = (total, contextTokens, rich) => {
	if (total === void 0) {
		const label = `unknown/${contextTokens ? formatKTokens(contextTokens) : "?"} (?%)`;
		return rich ? theme.muted(label.padEnd(TOKENS_PAD)) : label.padEnd(TOKENS_PAD);
	}
	const totalLabel = formatKTokens(total);
	const ctxLabel = contextTokens ? formatKTokens(contextTokens) : "?";
	const pct = contextTokens ? Math.min(999, Math.round(total / contextTokens * 100)) : null;
	return colorByPct(`${totalLabel}/${ctxLabel} (${pct ?? "?"}%)`.padEnd(TOKENS_PAD), pct, rich);
};
const formatKindCell = (kind, rich) => {
	const label = kind.padEnd(KIND_PAD);
	if (!rich) return label;
	if (kind === "group") return theme.accentBright(label);
	if (kind === "global") return theme.warn(label);
	if (kind === "direct") return theme.accent(label);
	return theme.muted(label);
};
const formatAgeCell = (updatedAt, rich) => {
	const padded = (updatedAt ? formatTimeAgo(Date.now() - updatedAt) : "unknown").padEnd(AGE_PAD);
	return rich ? theme.muted(padded) : padded;
};
const formatModelCell = (model, rich) => {
	const label = (model ?? "unknown").padEnd(MODEL_PAD);
	return rich ? theme.info(label) : label;
};
const formatFlagsCell = (row, rich) => {
	const label = [
		row.thinkingLevel ? `think:${row.thinkingLevel}` : null,
		row.verboseLevel ? `verbose:${row.verboseLevel}` : null,
		row.reasoningLevel ? `reasoning:${row.reasoningLevel}` : null,
		row.elevatedLevel ? `elev:${row.elevatedLevel}` : null,
		row.responseUsage ? `usage:${row.responseUsage}` : null,
		row.groupActivation ? `activation:${row.groupActivation}` : null,
		row.systemSent ? "system" : null,
		row.abortedLastRun ? "aborted" : null,
		row.sessionId ? `id:${row.sessionId}` : null
	].filter(Boolean).join(" ");
	return label.length === 0 ? "" : rich ? theme.muted(label) : label;
};
function toRows(store) {
	return Object.entries(store).map(([key, entry]) => {
		const updatedAt = entry?.updatedAt ?? null;
		return {
			key,
			kind: classifySessionKey(key, entry),
			updatedAt,
			ageMs: updatedAt ? Date.now() - updatedAt : null,
			sessionId: entry?.sessionId,
			systemSent: entry?.systemSent,
			abortedLastRun: entry?.abortedLastRun,
			thinkingLevel: entry?.thinkingLevel,
			verboseLevel: entry?.verboseLevel,
			reasoningLevel: entry?.reasoningLevel,
			elevatedLevel: entry?.elevatedLevel,
			responseUsage: entry?.responseUsage,
			groupActivation: entry?.groupActivation,
			inputTokens: entry?.inputTokens,
			outputTokens: entry?.outputTokens,
			totalTokens: entry?.totalTokens,
			totalTokensFresh: entry?.totalTokensFresh,
			model: entry?.model,
			modelProvider: entry?.modelProvider,
			providerOverride: entry?.providerOverride,
			modelOverride: entry?.modelOverride,
			contextTokens: entry?.contextTokens
		};
	}).toSorted((a, b) => (b.updatedAt ?? 0) - (a.updatedAt ?? 0));
}
async function sessionsCommand(opts, runtime) {
	const cfg = loadConfig();
	const resolved = resolveConfiguredModelRef({
		cfg,
		defaultProvider: DEFAULT_PROVIDER,
		defaultModel: DEFAULT_MODEL
	});
	const configContextTokens = cfg.agents?.defaults?.contextTokens ?? lookupContextTokens(resolved.model) ?? DEFAULT_CONTEXT_TOKENS;
	const configModel = resolved.model ?? DEFAULT_MODEL;
	const storePath = resolveStorePath(opts.store ?? cfg.session?.store);
	const store = loadSessionStore(storePath);
	let activeMinutes;
	if (opts.active !== void 0) {
		const parsed = Number.parseInt(String(opts.active), 10);
		if (Number.isNaN(parsed) || parsed <= 0) {
			runtime.error("--active must be a positive integer (minutes)");
			runtime.exit(1);
			return;
		}
		activeMinutes = parsed;
	}
	const rows = toRows(store).filter((row) => {
		if (activeMinutes === void 0) return true;
		if (!row.updatedAt) return false;
		return Date.now() - row.updatedAt <= activeMinutes * 6e4;
	});
	if (opts.json) {
		runtime.log(JSON.stringify({
			path: storePath,
			count: rows.length,
			activeMinutes: activeMinutes ?? null,
			sessions: rows.map((r) => {
				const model = resolveSessionModelRef(cfg, r, parseAgentSessionKey(r.key)?.agentId).model ?? configModel;
				return {
					...r,
					totalTokens: resolveFreshSessionTotalTokens(r) ?? null,
					totalTokensFresh: typeof r.totalTokens === "number" ? r.totalTokensFresh !== false : false,
					contextTokens: r.contextTokens ?? lookupContextTokens(model) ?? configContextTokens ?? null,
					model
				};
			})
		}, null, 2));
		return;
	}
	runtime.log(info(`Session store: ${storePath}`));
	runtime.log(info(`Sessions listed: ${rows.length}`));
	if (activeMinutes) runtime.log(info(`Filtered to last ${activeMinutes} minute(s)`));
	if (rows.length === 0) {
		runtime.log("No sessions found.");
		return;
	}
	const rich = isRich();
	const header = [
		"Kind".padEnd(KIND_PAD),
		"Key".padEnd(KEY_PAD),
		"Age".padEnd(AGE_PAD),
		"Model".padEnd(MODEL_PAD),
		"Tokens (ctx %)".padEnd(TOKENS_PAD),
		"Flags"
	].join(" ");
	runtime.log(rich ? theme.heading(header) : header);
	for (const row of rows) {
		const model = resolveSessionModelRef(cfg, row, parseAgentSessionKey(row.key)?.agentId).model ?? configModel;
		const contextTokens = row.contextTokens ?? lookupContextTokens(model) ?? configContextTokens;
		const total = resolveFreshSessionTotalTokens(row);
		const keyLabel = truncateKey(row.key).padEnd(KEY_PAD);
		const keyCell = rich ? theme.accent(keyLabel) : keyLabel;
		const line = [
			formatKindCell(row.kind, rich),
			keyCell,
			formatAgeCell(row.updatedAt, rich),
			formatModelCell(model, rich),
			formatTokensCell(total, contextTokens ?? null, rich),
			formatFlagsCell(row, rich)
		].join(" ");
		runtime.log(line.trimEnd());
	}
}

//#endregion
//#region src/cli/program/register.status-health-sessions.ts
function resolveVerbose(opts) {
	return Boolean(opts.verbose || opts.debug);
}
function parseTimeoutMs(timeout) {
	const parsed = parsePositiveIntOrUndefined(timeout);
	if (timeout !== void 0 && parsed === void 0) {
		defaultRuntime.error("--timeout must be a positive integer (milliseconds)");
		defaultRuntime.exit(1);
		return null;
	}
	return parsed;
}
async function runWithVerboseAndTimeout(opts, action) {
	const verbose = resolveVerbose(opts);
	setVerbose(verbose);
	const timeoutMs = parseTimeoutMs(opts.timeout);
	if (timeoutMs === null) return;
	await runCommandWithRuntime(defaultRuntime, async () => {
		await action({
			verbose,
			timeoutMs
		});
	});
}
function registerStatusHealthSessionsCommands(program) {
	program.command("status").description("Show channel health and recent session recipients").option("--json", "Output JSON instead of text", false).option("--all", "Full diagnosis (read-only, pasteable)", false).option("--usage", "Show model provider usage/quota snapshots", false).option("--deep", "Probe channels (WhatsApp Web + Telegram + Discord + Slack + Signal)", false).option("--timeout <ms>", "Probe timeout in milliseconds", "10000").option("--verbose", "Verbose logging", false).option("--debug", "Alias for --verbose", false).addHelpText("after", () => `\n${theme.heading("Examples:")}\n${formatHelpExamples([
		["openclaw status", "Show channel health + session summary."],
		["openclaw status --all", "Full diagnosis (read-only)."],
		["openclaw status --json", "Machine-readable output."],
		["openclaw status --usage", "Show model provider usage/quota snapshots."],
		["openclaw status --deep", "Run channel probes (WA + Telegram + Discord + Slack + Signal)."],
		["openclaw status --deep --timeout 5000", "Tighten probe timeout."]
	])}`).addHelpText("after", () => `\n${theme.muted("Docs:")} ${formatDocsLink("/cli/status", "docs.openclaw.ai/cli/status")}\n`).action(async (opts) => {
		await runWithVerboseAndTimeout(opts, async ({ verbose, timeoutMs }) => {
			await statusCommand({
				json: Boolean(opts.json),
				all: Boolean(opts.all),
				deep: Boolean(opts.deep),
				usage: Boolean(opts.usage),
				timeoutMs,
				verbose
			}, defaultRuntime);
		});
	});
	program.command("health").description("Fetch health from the running gateway").option("--json", "Output JSON instead of text", false).option("--timeout <ms>", "Connection timeout in milliseconds", "10000").option("--verbose", "Verbose logging", false).option("--debug", "Alias for --verbose", false).addHelpText("after", () => `\n${theme.muted("Docs:")} ${formatDocsLink("/cli/health", "docs.openclaw.ai/cli/health")}\n`).action(async (opts) => {
		await runWithVerboseAndTimeout(opts, async ({ verbose, timeoutMs }) => {
			await healthCommand({
				json: Boolean(opts.json),
				timeoutMs,
				verbose
			}, defaultRuntime);
		});
	});
	program.command("sessions").description("List stored conversation sessions").option("--json", "Output as JSON", false).option("--verbose", "Verbose logging", false).option("--store <path>", "Path to session store (default: resolved from config)").option("--active <minutes>", "Only show sessions updated within the past N minutes").addHelpText("after", () => `\n${theme.heading("Examples:")}\n${formatHelpExamples([
		["openclaw sessions", "List all sessions."],
		["openclaw sessions --active 120", "Only last 2 hours."],
		["openclaw sessions --json", "Machine-readable output."],
		["openclaw sessions --store ./tmp/sessions.json", "Use a specific session store."]
	])}\n\n${theme.muted("Shows token usage per session when the agent reports it; set agents.defaults.contextTokens to cap the window and show %.")}`).addHelpText("after", () => `\n${theme.muted("Docs:")} ${formatDocsLink("/cli/sessions", "docs.openclaw.ai/cli/sessions")}\n`).action(async (opts) => {
		setVerbose(Boolean(opts.verbose));
		await sessionsCommand({
			json: Boolean(opts.json),
			store: opts.store,
			active: opts.active
		}, defaultRuntime);
	});
}

//#endregion
export { registerStatusHealthSessionsCommands };