{"version":3,"file":"ScopeExit.js","sourceRoot":"","sources":["../src/ScopeExit.ts"],"names":[],"mappings":"AAAA;;;;;;;;GAQG;AACH,MAAM,OAAO,eAAe;IACxB,gBAAgB,CAAS,OAAO,CAAuB;IACvD,gBAAgB,CAAS,QAAQ,CAAQ;IAEzC,YAAoB,MAAgB;QAChC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QAEtB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACjC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACjC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACvD,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACrE,CAAC;IAED,oDAAoD;IACpD,IAAW,MAAM;QACb,OAAO,IAAI,CAAC,OAAO,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC;IAC1D,CAAC;IAED,qDAAqD;IACrD,IAAW,OAAO;QACd,OAAO,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC;IAClC,CAAC;IAED;;OAEG;IACI,IAAI;QACP,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,EAAE,CAAC;YACvB,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC;YAC5B,OAAO,IAAI,CAAC,OAAO,CAAC;YAEpB,OAAO,MAAM,EAA0B,CAAC;QAC5C,CAAC;QAED,OAAO,SAAS,CAAC;IACrB,CAAC;IAED,oFAAoF;IAC7E,IAAI;QACP,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI;YACpB,OAAO;QAEX,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,OAAO,IAAI,CAAC,OAAO,CAAC;IACxB,CAAC;IAEM,CAAC,MAAM,CAAC,OAAO,CAAC;QACnB,IAAI,CAAC,IAAI,EAAE,CAAC;IAChB,CAAC;IAEM,KAAK,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC;QAC9B,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;IACtB,CAAC;IAED,gBAAgB;IACT,MAAM,CAAC,OAAO,CAAsD,MAAgB;QACvF,OAAO,IAAI,eAAe,CAAW,MAAM,CAAC,CAAC;IACjD,CAAC;CACJ;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwCG;AACH,MAAM,UAAU,SAAS,CACrB,MAAgB;IAEhB,OAAO,eAAe,CAAC,OAAO,CAAW,MAAM,CAAwB,CAAC;AAC5E,CAAC","sourcesContent":["/**\n * The handle returned from `scopeExit` that allows calling or skipping the provided `onExit` function.\n *\n * Calling `.call()` will call the provided `onExit` function immediately, and prevent it from being called again.\n *\n * Calling `.skip()` will prevent the `onExit` function from being called.\n *\n * If neither `.call()` nor `.skip()` is called, the `onExit` function will be called automatically when the handle is disposed.\n */\nexport class ScopeExitHandle<const Callback extends (() => Promise<void> | void)> {\n    /** @internal */ private _onExit: Callback | undefined;\n    /** @internal */ private _skipped?: true;\n\n    private constructor(onExit: Callback) {\n        this._onExit = onExit;\n\n        this.call = this.call.bind(this);\n        this.skip = this.skip.bind(this);\n        this[Symbol.dispose] = this[Symbol.dispose].bind(this);\n        this[Symbol.asyncDispose] = this[Symbol.asyncDispose].bind(this);\n    }\n\n    /** Whether the `onExit` function has been called */\n    public get called() {\n        return this._onExit == null && this._skipped !== true;\n    }\n\n    /** Whether the `onExit` function has been skipped */\n    public get skipped() {\n        return this._skipped === true;\n    }\n\n    /**\n     * Call the `onExit` function immediately if it has not been called or skipped yet, and prevent it from being called again.\n     */\n    public call(): ReturnType<Callback> | void {\n        if (this._onExit != null) {\n            const onExit = this._onExit;\n            delete this._onExit;\n\n            return onExit() as ReturnType<Callback>;\n        }\n\n        return undefined;\n    }\n\n    /** Prevent the `onExit` function from being called if it has not been called yet */\n    public skip() {\n        if (this._onExit == null)\n            return;\n\n        this._skipped = true;\n        delete this._onExit;\n    }\n\n    public [Symbol.dispose]() {\n        this.call();\n    }\n\n    public async [Symbol.asyncDispose]() {\n        await this.call();\n    }\n\n    /** @internal */\n    public static _create<const Callback extends (() => Promise<void> | void)>(onExit: Callback) {\n        return new ScopeExitHandle<Callback>(onExit);\n    }\n}\n\n/**\n * Create a scope exit handle that will call the provided callback when disposed, to be used with `using` or `await using`.\n *\n * For example, this code:\n * ```typescript\n * import {scopeExit} from \"lifecycle-utils\";\n *\n * function example() {\n *     using exitHandle = scopeExit(() => {\n *         console.log(\"exiting scope\");\n *     });\n *     console.log(\"inside scope\");\n * }\n *\n * async function asyncExample() {\n *     await using exitHandle = scopeExit(async () => {\n *         await new Promise((resolve) => setTimeout(resolve, 100));\n *         console.log(\"exiting async scope\");\n *     });\n *     console.log(\"inside async scope\");\n * }\n *\n * example();\n * console.log(\"example done\");\n * console.log()\n *\n * await asyncExample();\n * console.log(\"asyncExample done\");\n * ```\n *\n * Will print this:\n * ```\n * inside scope\n * exiting scope\n * example done\n *\n * inside async scope\n * exiting async scope\n * asyncExample done\n * ```\n */\nexport function scopeExit<const Callback extends (() => Promise<void> | void)>(\n    onExit: Callback\n): ScopeExit<Callback> {\n    return ScopeExitHandle._create<Callback>(onExit) as ScopeExit<Callback>;\n}\n\nexport type ScopeExit<Callback extends (() => Promise<void> | void)> = {\n    readonly called: boolean,\n    readonly skipped: boolean,\n    call(): ReturnType<Callback> | void,\n    skip(): void\n} & (\n    (Promise<void> extends ReturnType<Callback> ? true : false) extends true\n        ? {[Symbol.asyncDispose](): Promise<void>}\n        : {[Symbol.dispose](): void}\n);\n"]}